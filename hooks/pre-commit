#!/usr/bin/env python3
"""
Enhanced Promptix pre-commit hook with automatic version management

Features:
- Auto-versioning on current.md changes
- Version switching via config.yaml current_version
- Auto-deployment when switching versions
- Safe, bypassable automation

User Flow:
1. Edit current.md → Auto-create new version
2. Change current_version in config.yaml → Auto-deploy that version to current.md
3. Request specific version via CLI
"""

import os
import sys
import shutil
import subprocess
import yaml
import re
import time
import errno
from datetime import datetime
from pathlib import Path
from typing import List, Optional, Tuple, Dict, Any


def print_status(message: str, status: str = "info"):
    """Print colored status messages"""
    icons = {
        "info": "📝",
        "success": "✅", 
        "warning": "⚠️",
        "error": "❌",
        "version": "🔄"
    }
    print(f"{icons.get(status, '📝')} {message}")


def is_hook_bypassed() -> bool:
    """Check if user wants to bypass the hook"""
    return os.getenv('SKIP_PROMPTIX_HOOK') == '1'


def get_staged_files() -> List[str]:
    """Get list of staged files from git"""
    try:
        result = subprocess.run(
            ['git', 'diff', '--cached', '--name-only'], 
            capture_output=True, 
            text=True, 
            check=True
        )
        return [f for f in result.stdout.strip().split('\n') if f]
    except subprocess.CalledProcessError:
        return []


def find_promptix_changes(staged_files: List[str]) -> Dict[str, List[str]]:
    """
    Find promptix-related changes, categorized by type
    Returns dict with 'current_md' and 'config_yaml' file lists
    """
    changes = {
        'current_md': [],
        'config_yaml': []
    }
    
    for file_path in staged_files:
        path = Path(file_path)
        
        # Check if it's in a prompts directory
        if len(path.parts) >= 2 and path.parts[0] == 'prompts':
            if path.name == 'current.md' and path.exists():
                changes['current_md'].append(file_path)
            elif path.name == 'config.yaml' and path.exists():
                changes['config_yaml'].append(file_path)
    
    return changes


def load_config(config_path: Path) -> Optional[Dict[str, Any]]:
    """Load YAML config file safely"""
    try:
        with open(config_path, 'r') as f:
            return yaml.safe_load(f)
    except Exception as e:
        print_status(f"Failed to load {config_path}: {e}", "warning")
        return None


def save_config(config_path: Path, config: Dict[str, Any]) -> bool:
    """Save YAML config file safely"""
    try:
        with open(config_path, 'w') as f:
            yaml.dump(config, f, default_flow_style=False, sort_keys=False)
        return True
    except Exception as e:
        print_status(f"Failed to save {config_path}: {e}", "warning")
        return False


def get_next_version_number(versions_dir: Path) -> int:
    """Get the next sequential version number"""
    if not versions_dir.exists():
        return 1
    
    version_files = list(versions_dir.glob('v*.md'))
    if not version_files:
        return 1
    
    version_numbers = []
    for file in version_files:
        match = re.match(r'v(\d+)\.md', file.name)
        if match:
            version_numbers.append(int(match.group(1)))
    
    return max(version_numbers) + 1 if version_numbers else 1


def atomic_create_version_file(
    versions_dir: Path,
    content: str,
    max_retries: int = 10,
    initial_backoff: float = 0.01
) -> Optional[Tuple[Path, str]]:
    """
    Atomically create a new version file with retry on collision.
    
    Uses os.open with O_CREAT|O_EXCL for atomic file creation.
    If the file already exists, retries with the next version number
    with exponential backoff.
    
    Args:
        versions_dir: Directory where version files are stored
        content: Content to write to the version file
        max_retries: Maximum number of retry attempts (default: 10)
        initial_backoff: Initial backoff time in seconds (default: 0.01)
    
    Returns:
        Tuple of (version_file_path, version_name) if successful, None otherwise
    """
    backoff = initial_backoff
    
    for attempt in range(max_retries):
        try:
            # Compute the next version number
            version_num = get_next_version_number(versions_dir)
            version_name = f'v{version_num:03d}'
            version_file = versions_dir / f'{version_name}.md'
            
            # Attempt atomic file creation using O_CREAT|O_EXCL
            # This will fail if the file already exists
            try:
                fd = os.open(
                    version_file,
                    os.O_CREAT | os.O_EXCL | os.O_WRONLY,
                    0o644
                )
            except OSError as e:
                if e.errno == errno.EEXIST:
                    # File was created by another process, retry with backoff
                    print_status(
                        f"Version {version_name} collision (attempt {attempt + 1}/{max_retries}), retrying...",
                        "warning"
                    )
                    time.sleep(backoff)
                    backoff *= 2  # Exponential backoff
                    continue
                else:
                    # Other OS error, re-raise
                    raise
            
            # Successfully created file, now write content
            try:
                with os.fdopen(fd, 'w') as f:
                    f.write(content)
                
                print_status(f"Created version file {version_name} atomically", "success")
                return (version_file, version_name)
                
            except Exception as e:
                # If writing fails, try to clean up the file
                try:
                    version_file.unlink()
                except Exception:
                    pass
                print_status(f"Failed to write version file {version_name}: {e}", "error")
                raise
                
        except Exception as e:
            print_status(
                f"Error during atomic version creation (attempt {attempt + 1}/{max_retries}): {e}",
                "error"
            )
            if attempt == max_retries - 1:
                # Last attempt failed
                print_status(f"Failed to create version file after {max_retries} attempts", "error")
                return None
            time.sleep(backoff)
            backoff *= 2
    
    print_status(f"Failed to create version file after {max_retries} attempts", "error")
    return None


def create_version_snapshot(current_md_path: str) -> Optional[str]:
    """
    Create a new version snapshot from current.md atomically.
    Uses atomic file creation with retry on collision to prevent race conditions.
    Returns the new version name (e.g., 'v005') or None if failed.
    """
    current_path = Path(current_md_path)
    prompt_dir = current_path.parent
    config_path = prompt_dir / 'config.yaml'
    versions_dir = prompt_dir / 'versions'
    
    # Skip if no config file
    if not config_path.exists():
        print_status(f"No config.yaml found for {current_md_path}", "warning")
        return None
    
    # Load config to check if this is a manual version change
    config = load_config(config_path)
    if not config:
        return None
    
    # Create versions directory if it doesn't exist
    versions_dir.mkdir(exist_ok=True)
    
    try:
        # Read current.md content
        with open(current_path, 'r') as f:
            current_content = f.read()
        
        # Prepare version content with header (will be added with actual version name)
        # We'll add the header in the atomic creation function
        
        # Atomically create the version file
        result = atomic_create_version_file(versions_dir, current_content)
        
        if not result:
            print_status(f"Failed to create version file atomically for {current_md_path}", "error")
            return None
        
        version_file, version_name = result
        
        # Add version header to the file
        with open(version_file, 'r') as f:
            content = f.read()
        
        created_at = datetime.now().isoformat()
        version_header = f"<!-- Version {version_name} - Created {created_at} -->\n"
        with open(version_file, 'w') as f:
            f.write(version_header)
            f.write(content)
        
        # Update config with new version info
        if 'versions' not in config:
            config['versions'] = {}
        
        # Get commit hash, handle git errors gracefully
        try:
            commit_hash = get_current_commit_hash()[:7]
        except Exception:
            commit_hash = 'unknown'
        
        config['versions'][version_name] = {
            'created_at': created_at,
            'author': os.getenv('USER', 'unknown'),
            'commit': commit_hash,
            'notes': 'Auto-versioned on commit'
        }
        
        # Note: Do NOT automatically set current_version here
        # current_version should only be set when explicitly switching versions
        # The loader will use current.md when current_version is not set
        
        # Update metadata
        if 'metadata' not in config:
            config['metadata'] = {}
        config['metadata']['last_modified'] = datetime.now().isoformat()
        
        # Save updated config
        if save_config(config_path, config):
            # Stage the new files
            stage_files([str(version_file), str(config_path)])
            return version_name
        else:
            print_status(f"Failed to save config for version {version_name}", "error")
            return None
        
    except Exception as e:
        print_status(f"Failed to create version snapshot: {e}", "error")
        return None


def handle_version_switch(config_path: str) -> bool:
    """
    Handle version switching in config.yaml
    If current_version changed, deploy that version to current.md
    """
    config_path = Path(config_path)
    prompt_dir = config_path.parent
    current_md = prompt_dir / 'current.md'
    versions_dir = prompt_dir / 'versions'
    
    # Load config
    config = load_config(config_path)
    if not config:
        return False
    
    # Check if current_version is specified
    current_version = config.get('current_version')
    if not current_version:
        return False
    
    # Check if the version file exists
    version_file = versions_dir / f'{current_version}.md'
    if not version_file.exists():
        print_status(f"Version {current_version} not found in {versions_dir}", "warning")
        return False
    
    try:
        # Check if current.md differs from the specified version
        if current_md.exists():
            with open(current_md, 'r') as f:
                current_content = f.read()
            with open(version_file, 'r') as f:
                version_content = f.read()
                # Remove version header if present
                version_content = re.sub(r'^<!-- Version.*? -->\n', '', version_content)
            
            if current_content.strip() == version_content.strip():
                return False  # Already matches, no need to deploy
        
        # Deploy the version to current.md
        shutil.copy2(version_file, current_md)
        
        # Remove version header from current.md
        with open(current_md, 'r') as f:
            content = f.read()
        
        # Remove version header
        content = re.sub(r'^<!-- Version.*? -->\n', '', content)
        with open(current_md, 'w') as f:
            f.write(content)
        
        # Stage current.md
        stage_files([str(current_md)])
        
        print_status(f"Deployed {current_version} to current.md", "version")
        return True
        
    except Exception as e:
        print_status(f"Failed to deploy version {current_version}: {e}", "warning")
        return False


def get_current_commit_hash() -> str:
    """Get current git commit hash"""
    try:
        result = subprocess.run(
            ['git', 'rev-parse', 'HEAD'], 
            capture_output=True, 
            text=True, 
            check=True
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError:
        return 'unknown'


def stage_files(files: List[str]):
    """Stage files for git commit"""
    try:
        subprocess.run(['git', 'add'] + files, check=True)
    except subprocess.CalledProcessError as e:
        print_status(f"Failed to stage files: {e}", "warning")


def main():
    """Main hook logic"""
    
    # Check for bypass
    if is_hook_bypassed():
        print_status("Promptix hook skipped (SKIP_PROMPTIX_HOOK=1)", "info")
        sys.exit(0)
    
    # Get staged files
    staged_files = get_staged_files()
    if not staged_files:
        sys.exit(0)
    
    # Find promptix-related changes
    promptix_changes = find_promptix_changes(staged_files)
    
    if not promptix_changes['current_md'] and not promptix_changes['config_yaml']:
        # No promptix changes
        sys.exit(0)
    
    print_status("Promptix: Processing version management...", "info")
    
    processed_count = 0
    
    # Handle current.md changes (auto-versioning)
    for current_md_path in promptix_changes['current_md']:
        try:
            version_name = create_version_snapshot(current_md_path)
            if version_name:
                print_status(f"{current_md_path} → {version_name}", "success")
                processed_count += 1
            else:
                print_status(f"{current_md_path} (skipped)", "warning")
        except Exception as e:
            print_status(f"{current_md_path} (error: {e})", "warning")
    
    # Handle config.yaml changes (version switching)
    for config_path in promptix_changes['config_yaml']:
        try:
            if handle_version_switch(config_path):
                processed_count += 1
        except Exception as e:
            print_status(f"{config_path} version switch failed: {e}", "warning")
    
    if processed_count > 0:
        print_status(f"Processed {processed_count} version operation(s)", "info")
        print_status("💡 Tip: Use 'SKIP_PROMPTIX_HOOK=1 git commit' to bypass", "info")
    
    # Always exit successfully - never block commits
    sys.exit(0)


if __name__ == '__main__':
    main()
